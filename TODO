
Makefile:
------------

* `arduino-cli board list` will list all attached boards.
  If BOARD is not set, parse this and get the attached board for the specified serial port.

* Library `make install` needs a flag for arch-specific .h file installation
* `include_dirs` should include arch-specific target.


Debugger:
------------

On-device service capabilities:
  * SAMD: memory map; use __bss_end__, sbrk(0);
  * SAMD: register dump - get $PC. Are other registers correct?
    dump r0..r15 and CPSR
    See ARM ABI Procedure Call Standard, 32bit. (sec 6.1.1 "core registers")
  * SAMD: watchdog timer / reset [just call NVIC_SystemReset() ?]

  * SAMD: Implement 'monitor mode debugging'. see e.g.:
  https://github.com/NordicPlayground/j-link-monitoring-mode-debugging

Client:

  * Use `arduino-cli board list` to autodetect the attached board for the specified serial port.

  --------

  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.
    * This would be very tricky for frames below #0; especially if the register is live/implicit
      in the current frame, it could make the current frame have undefined behavior. If it was
      pushed on the stack but not in frame 'n-1' then it could cause undefined behavior in that
      intermediate frame.

  * types.py should handle union type? bit fields?
  * Filter __dbg_service and __vector17 out of stack trace report and `frame` commands?

  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`, locals, etc?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.

SAM D21 support: (See Cortex-M0+ Technical Reference Manual)
* Breakpoint unit support
* Watchpoint unit support
* Single-step support
* ... cleaner backtrace via ARM-standard frame pointer record walking.


