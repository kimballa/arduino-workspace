
Makefile:
------------

* `arduino-cli board list` will list all attached boards.
  If BOARD is not set, parse this and get the attached board for the specified serial port.

Debugger:
------------

On-device service capabilities:
  * SAMD: Implement 'monitor mode debugging'. see e.g.:
  https://github.com/NordicPlayground/j-link-monitoring-mode-debugging
  https://interrupt.memfault.com/blog/cortex-m-debug-monitor


Client:

  * BUG: It seems possible to get binutils.DemangleThread into a borked state if something
    goes wrong in c++filt (Errno 32, broken pipe). [Maybe because our ^C's are getting passed
    along to the subprocesses? Or other issues like if the serial conn experiences a reset?]
    ... maybe attempt to create a new Popen object *within* the comm thread?
    [I added a lock held during the lifetime of DemangleThread.demangle(). Maybe fixed now?
    I am suspicious that the BreakpointCreateThread()'s use of demangle() is somehow interacting
    poorly with the main thread's use of demangle() in 'get_backtrace()' ?]

  * The first time we hit a given BKPT, we handle it gracefully and move past it. Subsequent
    'step' and 'continue' commands work. But if we trigger that same BKPT a second time, our
    $PC gets locked on the BKPT instruction (e.g. at 0x4928 in __dbg_break()) and we cannot
    continue/step over it.


  * dwarf info: CUNS.add_entry() takes a 'name' field which we use for name->typ mapping.
    If this names a member function with the same name as its containing class, we may have
    a conflict. We need to either retain only fully-canonicalized names ('typ.name') OR only
    retain nesting-level-0 names at the CUNS name level. See comment at types.py, line 222.

  * Use `arduino-cli board list` to autodetect the attached board for the specified serial port.

  * breakpoint.Breakpoint() needs ability to register a hw addr as discovered in
    __acknowledge_pause(). nb that the literal BKPT instruction inside __dbg_break() is not
    helpful; we need the 'real' $PC from entering the breakpoint method in order to register
    break sites.

  * Bug: If `regs` command is given in hide-stack-frames mode, it should show registers from
    the top-most visible stack frame, not the literal current machine state.

      ... in general it should take a frame-id and use 0 as the default.

  * Bug: 'info debug_status' shows a uint8_t @ 2000011e and prints its value.
    ... but 'info cnt' does *not* print the value, just type and location. Why?
    note also formatting difference:

				(adbg) info debug_status
				debug_status: uint8_t
				debug_status: 2000011e (1)
				13
				(adbg) info cnt
				uint8_t cnt                      # 'type name' vs 'name: type' above.
				cnt: 2000011c (1)
				(adbg) print cnt                 # You can still read the value.
				10                               # but you gotta do it explicitly.

  --------

  * Add formatted print keywords:
      `print/d`, `print/b`, `print/x` for integers.
      `print/a`, `print/u`, `print/d`, `print/x` for strings in ascii, utf8, or dec/hex byte vals.

      ... should these modifiers also apply to 'locals' and 'frame' ?
      At minimum they need to also apply to 'info'.

  * 'frame' command should also format and print the CFI table (like we verboseprint during unwind.)

  * ARM: When returning from interrupt, $LR has a bunch of special flag values that do things like
    switch between $MSP and $PSP. We should parse these and operate on the appropriate stack.
    * As well as update correct MSP/PSP in ARMThumbArchInterface.finish_register_unwind().

  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.
    * This would be very tricky for frames below #0; especially if the register is live/implicit
      in the current frame, it could make the current frame have undefined behavior. If it was
      pushed on the stack but not in frame 'n-1' then it could cause undefined behavior in that
      intermediate frame.

  * types.py should handle union type? bit fields?

  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`, locals, etc?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.

SAM D51 support: (See Cortex-M4 Technical Reference Manual)
* Breakpoint unit support
  * Create HW breakpoint
  * Delete HW breakpoint
  * Disable/enable HW breakpoint
* Watchpoint unit support
* Single-step support


