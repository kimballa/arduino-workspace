
Makefile:
------------

* `arduino-cli board list` will list all attached boards.
  If BOARD is not set, parse this and get the attached board for the specified serial port.

Debugger:
------------

On-device service capabilities:
  * SAMD: register dump:
    dump r0..r15 and CPSR (also CONTROL?)
    naming of 16 registers: r0..r12, SP, LR, PC
      r11 may also be called FP
    PC[0] needs to be zeroed as it encodes the arm/thumb state. (PC = PC & ~1)
    See ARM ABI Procedure Call Standard, 32bit. (sec 6.1.1 "core registers")

  * SAMD: Implement 'monitor mode debugging'. see e.g.:
  https://github.com/NordicPlayground/j-link-monitoring-mode-debugging

Client:

  * Use `arduino-cli board list` to autodetect the attached board for the specified serial port.
  * Show user a list of available platforms and arch's.
  * Cannot parse SAMD51-compiled empty.elf

  --------

  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.
    * This would be very tricky for frames below #0; especially if the register is live/implicit
      in the current frame, it could make the current frame have undefined behavior. If it was
      pushed on the stack but not in frame 'n-1' then it could cause undefined behavior in that
      intermediate frame.

  * types.py should handle union type? bit fields?
  * Filter __dbg_service and __vector17 out of stack trace report and `frame` commands?

  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`, locals, etc?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.

SAM D21 support: (See Cortex-M0+ Technical Reference Manual)
* Breakpoint unit support
* Watchpoint unit support
* Single-step support
* ... cleaner backtrace via ARM-standard frame pointer record walking.


