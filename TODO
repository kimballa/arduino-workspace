
Makefile:
------------

* `arduino-cli board list` will list all attached boards.
  If BOARD is not set, parse this and get the attached board for the specified serial port.

Debugger:
------------

On-device service capabilities:
  * SAMD: Implement 'monitor mode debugging'. see e.g.:
  https://github.com/NordicPlayground/j-link-monitoring-mode-debugging
  https://interrupt.memfault.com/blog/cortex-m-debug-monitor


Client:
  * Get `backtrace` fn working 
    * CFA common block notes 'return addr column: 14' -- r14 is LR and holds ret val. Do we process
      correctly?
      -- note that ArchInterface.stack_frame_size() currently subtracts `ret_addr_size` from 
         the CFA because we want the 'pre-return' point to adjust to so we can then do an sram read
         of the ret addr. But we shouldn't assume ret_addr is pushed on frame entry. ARM doesn't;
         we need an arch-specific way of getting the ret addr. (Or, just read the CIE block more
         carefully.)
      -- Make the ret_addr_size subtraction an AVR-specific thing
         (Or, adjust our definition of 'frame size' to also include the ret addr bytes and AVR
         should adjust down from there?)
      -- don't just blindly read the next few bytes of sram up from the CFA as the ret addr; either
         handle this in the unwind_registers properly, or add an ArchInterface method to get the
         return address after the debug_frame instructions / method epilogue has unwound the stack.
    * (OK) It also looks like __dbg_service has the cfi_e for TC4_Handler. what's up?
      * (OK) __dbg_service starts at 43b0h but the sym has it at 43b1h. Which isn't a valid addr; $PC
        needs to be halfword-aligned. But the thumb-state-bit = 1 so the PC reg will show 43b1h 
        even if the actual memory addr is 43b0h. For ARM/Thumb, we need to cleanse the symtab $PC
        values.

  * Verify `empty.elf` CFA records are actually useful?

  * dwarf info: CUNS.add_entry() takes a 'name' field which we use for name->typ mapping.
    If this names a member function with the same name as its containing class, we may have
    a conflict. We need to either retain only fully-canonicalized names ('typ.name') OR only
    retain nesting-level-0 names at the CUNS name level. See comment at types.py, line 222.

  * Use `arduino-cli board list` to autodetect the attached board for the specified serial port.


  --------

  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.
    * This would be very tricky for frames below #0; especially if the register is live/implicit
      in the current frame, it could make the current frame have undefined behavior. If it was
      pushed on the stack but not in frame 'n-1' then it could cause undefined behavior in that
      intermediate frame.

  * types.py should handle union type? bit fields?
  * Filter __dbg_service and __vector17 out of stack trace report and `frame` commands?

  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`, locals, etc?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.

SAM D21 support: (See Cortex-M0+ Technical Reference Manual)
* Breakpoint unit support
  * Create HW breakpoint
  * Delete HW breakpoint
  * Disable/enable HW breakpoint
  * ... should DBGBREAK() use `BKPT` instr on ARM? By invoking the debug mon irq, we can then
    do a proper single-step from there.
  * ... timer-irq-driven breaks need a way to 'kick off' single-step such that it gets back
    to the bottom of the timer irq fn, enables single-step mode, and then returns from the irq
    to execute the 1 opcode. __dbg_service() probably needs to return a value or set a status flag
    checked in the irq fn.
* Watchpoint unit support
* Single-step support
* ... cleaner backtrace via ARM-standard frame pointer record walking.


