
Makefile:
------------

* `arduino-cli board list` will list all attached boards.
  If BOARD is not set, parse this and get the attached board for the specified serial port.

Debugger:
------------

On-device service capabilities:

  * Runtime confirmation of device-identification w/o relying on user config or static #define's:
    Send an identifying dword as the first sentence in the arch_specs response list.
    - On ARM, use the $CPUID register to get a uint32_t's worth of identifier
    - On AVR, read the 3 signature bytes
      (https://microchipsupport.force.com/s/article/How-to-read-signature-byte)

    If arduino.arch is "auto" parse this int and then reload arduino.arch based on a lookup table.
    arduino.platform=auto can use arduino.arch="auto", and the most conservative number of gpio pins.

  * The arch specs list should be captured by the dump process and saved to the image file. The
    local image service should reproduce this exactly.


  SAM D51 support: (See Cortex-M4 Technical Reference Manual)
  * Watchpoint unit support

  ARMv7 arch ref manual: pg C1-752 - a BKPT in an IRQ w/ higher priority than debugmon will
  trigger a HardFault.

    Implement a HardFault handler that logs the IRQ BKPT $PC and set the MON_PEND bit to
    go to DebugMon after the IRQ is finished. Document this "delayed breakpoint" behavior.

    A consequence is that we cannot single-step (or inspect state while halted) within IRQs.

    watchpoints are ignored in hgher-prio IRQs. Document this.
    FPB breakpoints may be ignored or HardFaulted; impl.defined. Test. Document.

  * Add a `next` command that will 'step' until filename:lineno changes.
    (Can we use addr2line to figure this out in advance and implement 'step (n)' or do
    we just need to keep STEPping?)

  * Add a 'step return' command that uses CFI to figure out the $LR value (return point) for
    the method under debug, and set a hw bp for that addr.

  * A 'step n' command can be implemented using DWT comparator 0 in CYCCOUNT matching mode.
    Set DWT_COMP0 to 'n+k' and reset CYCCNT <- 0. CYCCNT increments only if DWT_CTRL.CYCCNTENA is set;
    we should enable this bit at the last possible moment before returning from the interrupts.
    (And we should disable it on interrupt entry.) We need to adjust DWT_COMP0 by 'k' which is the
    number of further cycles it takes to destack the IRQ frame and transition back to user code.

  * Add a 'skinny breakpoints' #define macro in dbg.h that just converts `BREAK()` to `__BKPT()`.


Client:

  * Use `arduino-cli board list` to autodetect the attached board for the specified serial port.

  * breakpoint.Breakpoint() needs ability to register a hw addr as discovered in
    __acknowledge_pause(). nb that the literal BKPT instruction inside __dbg_break() is not
    helpful; we need the 'real' $PC from entering the breakpoint method in order to register
    break sites.

  * Add watchpoint command.

  --------

  * Add formatted print keywords:
      `print/d`, `print/b`, `print/x` for integers.
      `print/a`, `print/u`, `print/d`, `print/x` for strings in ascii, utf8, or dec/hex byte vals.

      ... should these modifiers also apply to 'locals' and 'frame' ?
      At minimum they need to also apply to 'info'.

  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.
    * This would be very tricky for frames below #0; especially if the register is live/implicit
      in the current frame, it could make the current frame have undefined behavior. If it was
      pushed on the stack but not in frame 'n-1' then it could cause undefined behavior in that
      intermediate frame.

  * types.py should handle bit fields?

  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`, locals, etc?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.


