
Makefile:
------------


Debugger:
------------

On-device service capabilities:

Client:

  - When we get a `Paused ...` message, parse the bitNum and bitfieldAddr.
    ... if bitfieldAddr != null ...
  - Within the conn listener, issue the correct commands to get the non-debugger PC.
  - Add a Breakpoint to the BreakpointDatabase for pc with the bitnum and bitfield addr.
  - Print out the stopped-at-breakpoint information 

  - Add bp enable/disable commands.
  - Add bp list command.


  --------

  * Even if we can't add brand new breakpoints at arbitrary locations, we can at least
    control/suppress existing ones.
    - Server could have a memory array for $PC values we /don't/ stop at. If $prevPC
      is on the list, don't actually go into the service.
    - Could maybe also manage this client-side; higher-latency, but would have unlimited
      memory for bp suppressions and possibly less brittle asm work.
  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.
    * This would be very tricky for frames below #0; especially if the register is live/implicit
      in the current frame, it could make the current frame have undefined behavior. If it was
      pushed on the stack but not in frame 'n-1' then it could cause undefined behavior in that
      intermediate frame.

  * types.py should handle union type? bit fields?
  * Filter __dbg_service and __vector17 out of stack trace report and `frame` commands?

  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`, locals, etc?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.

SAM D21 support: (See Cortex-M0+ Technical Reference Manual)
* Breakpoint unit support
* Watchpoint unit support
* Single-step support
* ... cleaner backtrace via ARM-standard frame pointer record walking.


