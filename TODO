
Makefile:
------------


Debugger:
------------

On-device service capabilities:

Client:
  * Bug: Pointer type cannot be established just by using isinstance(PointerType/ReferenceType);
    e.g. Const(Pointer(some_base)) is still a ptr, and should still be printed by repl as 0xHHHH
    in `locals`. See get_byte.dump, `locals 2` and look at `this`.
      * Needs an isPointerType() method that looks through wrapped types.

  * Bug: method signature should probably not show explicit `this`... isn't it marked artificial?
      Method scope: public uint8_t I2C4BitNhdByteSender::readByte(const class I2C4BitNhdByteSender* this,
      uint8_t ctrlFlags, uint8_t enFlag)

      Method DIE at offset 0x6113

      (get_byte.dump; `locals 2`)

  * Link type information for methods & variables to Symbols in Debugger initialization
    after parsing dwarf_info().
  * add notion of "current frame" that can be adjusted rather than just as immediate arg
    to `frame` / `\f`

  --------

  * In the case of e.g. NewhavenLcd0440::write(), we have an initial method declaration( #1),
    then another subprogram (#2) references it with DW_AT_specification. A third subprogram of
    the same name references #2 with DW_AT_abstract_origin. Both #2 and #3 set #1 as origin;
    effectively #2 and 3 are "sibling" definitions in this pointer tree. Should 3 point to 2
    points to 1?

    If we are doing a `locals` within #3, and #3 copied in or referred to all the variables
    defined in #2, we may have more thorough enumeration of all local variables (some are
    present in #2 and not #3) but they may have location eval instructions not valid for
    the $PC..

  * Even if we can't add brand new breakpoints at arbitrary locations, we can at least
    control/suppress existing ones.
    - Server could have a memory array for $PC values we /don't/ stop at. If $prevPC
      is on the list, don't actually go into the service.
    - Could maybe also manage this client-side; higher-latency, but would have unlimited
      memory for bp suppressions and possibly less brittle asm work.
  * Can we implement a 'setlocal' ?
    * Would need to use call frame info to determine where on the stack it lives...
      or where on the stack frame above the local the register got saved.

  * types.py should handle union type? bit fields?
  * Filter __dbg_service and __vector17 out of stack trace report and `frame` commands?

  * Optionally embed ELF file in core dump file, for all-in-one dump file w/o separate .elf.

SAM D21 support: (See Cortex-M0+ Technical Reference Manual)
* Breakpoint unit support
* Watchpoint unit support
* Single-step support
* ... cleaner backtrace via ARM-standard frame pointer record walking.


